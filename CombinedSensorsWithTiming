/*
 * Potentially usful websites
 * https://www.digikey.jp/htmldatasheets/production/1766819/0/0/1/robotics-with-the-boe-bot-student-guide.html
 */


#include <Wire.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "Adafruit_VL6180X.h"

// Setup the lidar -------------------------------------------------------
Adafruit_VL6180X vl = Adafruit_VL6180X();

Adafruit_SSD1306 display = Adafruit_SSD1306();

#if (SSD1306_LCDHEIGHT != 32)
 #error("Height incorrect, please fix Adafruit_SSD1306.h!");
#endif
//-------------------------------------------------------------------------

// Setup the robot Servo---------------------------------------------------
#include <Servo.h>  
int servoPin1 = 12; //Right
int servoPin2 = 13; //Left
Servo servoLeft;       // Declare left and right servos
Servo servoRight;
//-------------------------------------------------------------------------

// Setup the Ultrasonic Sensor---------------------------------------------
// defines pins numbers where sensor is attached
const int trigPinLEFT = 5;
const int echoPinLEFT = 6;
const int trigPinRIGHT = 9;
const int echoPinRIGHT = 10;
//-------------------------------------------------------------------------

// defines variables-------------------------------------------------------
long duration, distance, distanceLEFT, distanceRIGHT, timeL1, timeL2, timeR1, timeR2, timer, time1, time2;
int j, k;
//-------------------------------------------------------------------------

void setup()
{
  pinMode(trigPinLEFT, OUTPUT); // Sets the trigPin as an Output
  pinMode(echoPinLEFT, INPUT); // Sets the echoPin as an Input
  pinMode(trigPinRIGHT, OUTPUT); // Sets the trigPin as an Output
  pinMode(echoPinRIGHT, INPUT); // Sets the echoPin as an Input
  Serial.begin(9600); // Starts the serial communication

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3C (for the 128x32)
  // init done
  display.display();
  delay(1000);
  
  Serial.println("Adafruit VL6180x test!");
  if (! vl.begin()) {
    Serial.println("Failed to find sensor");
    while (1);
  }
  Serial.println("Sensor found!");

  // text display big!
  display.setTextSize(4);
  display.setTextColor(WHITE);
}

void loop()
{
start:
  timer = millis(); // start timer
  // Initialising the readings from the lidar
  uint8_t distanceFront = vl.readRange(); // Taking measurements for the front distance
  uint8_t status = vl.readRangeStatus();  // Taking the status of the lidar, incase of an error
  Serial.print("Range: "); Serial.println(distanceFront);
  // Checking for errors from the lidar sensor.
  ErrorCheck(status);

  /*// Initialising the readings from Ultrasonic sensors and attaching servos
  SonarSensor(trigPinLEFT, echoPinLEFT);
  distanceLEFT = distance;
  
  servoRight.attach(servoPin1);  // Attach right signal to pin 12
  servoLeft.attach(servoPin2);   // Attach left signal to pin 13
  
  SonarSensor(trigPinRIGHT, echoPinRIGHT);
  distanceRIGHT = distance;
  */
  
// 1st run follow left wall-----------------------------------------------
  servoRight.attach(servoPin1);  // Attach right signal to pin 12
  servoLeft.attach(servoPin2);  // Attach right signal to pin 13
  ServoR.write(0);
  ServoL.write(180);
  delay(400);

  timeL1 = millis();
  while ((distanceLEFT < 50) || (distanceRIGHT < 50) || (distanceFront < 200)){
    WallFollower(distanceFront);
    TL(distanceFront);
  }
  timeL2 = millis() // store the time the loop exited (End of the maze)
  ServoL.detach(); // Stop the motors completely
  ServoR.detach();
  timeL2 = timeL2 - timeL1; //Serial.print(timeL2); Serial.print("\n");
  timeL2 = timeL2 / 1000; //Serial.print(timeL2);

// 2nd run follow right wall----------------------------------------------
  servoRight.attach(servoPin1);  // Attach right signal to pin 12
  servoLeft.attach(servoPin2);  // Attach right signal to pin 13
  servoRight.write(0);
  servoLeft.write(180);
  delay(400);
  
  SonarSensor(trigPinLEFT, echoPinLEFT);
  distanceLEFT = distance;
  SonarSensor(trigPinRIGHT, echoPinRIGHT);
  distanceRIGHT = distance;

  timeR1 = millis();
  while ((distanceLEFT < 50) || (distanceRIGHT < 50) || (distanceFront < 200)){
    WallFollower(distanceFront);
    RL(distanceFront);
  }
  timeR2 = millis(); // Store the time the loop exited (End of maze)
  servoLeft.detach(); // Stop the motors completely
  servoRight.detach();
  timeR2 = timeR2 - timeR1; //Serial.print(timeL2); Serial.print("\n");
  timeR2 = timeR2 / 1000; //Serial.print(timeL2)

// Choose the fastest wall to follow--------------------------------------
  servoRight.attach(servoPin1);
  servoLeft.attach(servoPin2);
  ServoR.write(0);
  delay(100);
  ServoRight.write(0);
  servoLeft.write(180);
  delay(400);

  SonarSensor(trigPinLEFT, echoPinLEFT);
  distanceLEFT = distance;
  SonarSensor(trigPinRIGHT, echoPinRIGHT);
  distanceRIGHT = distance;

  time1 = millis();
  if (timeL2 > timeR2){
    while ((distanceFront < 50) || (LeftSensor < 50) || (RightSensor < 50)) {
      WallFollower(distanceFront);
      TR(distacneFront);
      } 
    } else {
      while ((distanceFront < 50) || (LeftSensor < 50) || (RightSensor < 50)) {
      WallFollower(distanceFront);
      Tl(distacneFront);
      }
    }
      time2 = millis();
  servoLeft.detach(); // Stop the motors completely
  servoRight.detach();
  time2 = time2 - time1; //Serial.print(timeL2); Serial.print("\n");
  time2 = time2 / 1000; //Serial.print(timeL2);
  
}

// Functions---------------------------------------------------------------

// Ultrasonic sensor reading function--------------------------------------
void SonarSensor(int trigPin,int echoPin)
{
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  duration = pulseIn(echoPin, HIGH);
  distance = duration*0.034/2;
  //distance = (duration/2) / 29.1;
}

// Wall following function
void WallFollower(uint8_t distanceFront)
{
  delay(10);
  SonarSensor(trigPinLEFT, echoPinLEFT);
  distanceLEFT = distance;
  SonarSensor(trigPinRIGHT, echoPinRIGHT);
  distanceRIGHT = distance;
  servoRight.write(0);
  servoLeft.write(180);

  if ((distanceFront < 50) && (distanceLEFT > 10) && (distanceRIGHT < 10)){ // Turns Left in a corner

    servoLeft.writeMicroseconds(1400);         // Left wheel clockwise
    servoRight.writeMicroseconds(1400);        // Right wheel anticlockwise
    delay(50);
  }
  else if ((distanceFront < 50) && (distanceLEFT < 10) && (distanceRIGHT > 10)){ // Turns right in a corner

    servoRight.writeMicroseconds(1600);         // Right wheel clockwise
    servoLeft.writeMicroseconds(1600);          // Left wheel anticlockwise
    delay(50);
  }
  else if ((distanceFront < 90) && (distanceLEFT < 9) && (distanceRIGHT > 9)){ // Continue straight on
    
    servoLeft.writeMicroseconds(1700);
    servoRight.writeMicroseconds(1700);
    delay(50);
  }
  else if (distanceLEFT < 7) { // getting too close to the right wall, adjust left
    servoLeft.write(180);
    servoRight.write(90);
  } else if (distanceRIGHT < 7) { // getting too close to the left wall, adjust right
    servoLeft.write(90);
    servoRight.write(0);
  }
}


// Turn left at T junction------------------------------------------------

void TL(uint8_t distanceFront) {
  if ((distanceFront < 6) && (distanceLEFT > 10) && (distanceRIGHT > 10)) {
    
      servoLeft.writeMicroseconds(1420);         // Left wheel clockwise
      servoRight.writeMicroseconds(1420);        // Right wheel anticlockwise
      delay(50);
  }
}


// Turn right at T junction-----------------------------------------------

void TR(uint8_t distanceFront) {
  if ((distanceFront < 6) && (distanceLEFT > 10) && (distanceRIGHT > 10)) {
    
      servoRight.writeMicroseconds(1580);         // Right wheel clockwise
      servoLeft.writeMicroseconds(1580);          // Left wheel anticlockwise
      delay(50);
  }
}


// Lidar error check function----------------------------------------------
void ErrorCheck(uint8_t status){
  // Some error occurred, print it out!
  if  ((status >= VL6180X_ERROR_SYSERR_1) && (status <= VL6180X_ERROR_SYSERR_5)) {
    Serial.println("System error");
  }
  else if (status == VL6180X_ERROR_ECEFAIL) {
    Serial.println("ECE failure");
  }
  else if (status == VL6180X_ERROR_NOCONVERGE) {
    Serial.println("No convergence");
  }
  else if (status == VL6180X_ERROR_RANGEIGNORE) {
    Serial.println("Ignoring range");
  }
  else if (status == VL6180X_ERROR_SNR) {
    Serial.println("Signal/Noise error");
  }
  else if (status == VL6180X_ERROR_RAWUFLOW) {
    Serial.println("Raw reading underflow");
  }
  else if (status == VL6180X_ERROR_RAWOFLOW) {
    Serial.println("Raw reading overflow");
  }
  else if (status == VL6180X_ERROR_RANGEUFLOW) {
    Serial.println("Range reading underflow");
  }
  else if (status == VL6180X_ERROR_RANGEOFLOW) {
    Serial.println("Range reading overflow");
  }
  delay(10);
}
